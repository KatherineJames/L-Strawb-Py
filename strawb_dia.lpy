import matplotlib.pyplot as plt
from openalea.plantgl.all import *
import random as rd
from numpy import random as rng
import decimal
import numpy as ny
import math
import time
import json

rd.seed(42)

# Load default/external specify_params
specify_params = True
if specify_params:
    extern(N_TRUSSES = 3,N_BERRIES = 4, BERRY_SIZE = 0.45, N_STEPS_PED = 2, N_STEPS_CEL = 2, LEAFS = 30, LEAF_AREA = 3, N_STEPS_PETIOLE = 5, PETIOLE_LEN = 1, PEDUNCLE_LEN = 1, PEDICEL_LEN = 1, PEDICEL_RADIUS = 0.03,  PETIOLE_RADIUS = 0.1, PEDUNCLE_RADIUS = 0.1) 
  
#LeafArea
Lf = 0

#Global plant location variable
Px = 0
Py = 0

spiral = 0
spiral_angle = []


#Textures for the plants
#context().turtle.setMaterial(9,ImageTexture('textures/leaf.png'))
#context().turtle.setMaterial(8,ImageTexture('textures/stem_drk.png'))
#context().turtle.setMaterial(10,ImageTexture('textures/strawb.jpeg'))

with open('strawberry_parameters.json') as file:
  data = json.load(file)

json_dict = data

def SaveArea(x):
    global Lf
    Lf = x

#generate a temp for the day
def RanTemp(x, max, low):
    return round(rd.uniform(low[x], max[x]), 1)	

#Number of infloresences/strawberries on a single stem
inflo = json_dict["inflorescence"]
Petiole = json_dict["petiole"]
Truss_split_length = [4, 6]

#List of mean temperatures from the UK of 2020 and the max and min temps recorded for that day
mean = json_dict["temperatures"]["mean"]
min = json_dict["temperatures"]["min"]
max = json_dict["temperatures"]["max"]

#List of each month and days (not including leap year)
MnthsDays = [[1, 31], [2, 28], [3, 31], [4, 30], [5, 31], [6, 30], [7, 31], [8, 31], [9, 30], [10, 31], [11, 30], [12, 31]]
#List to store each temp
tempHigh = []
tempLow = []
#generate sigmoid curve  for petiole length

leaves_circle_pos = []
fruit_pos = []

def Sigmoid(x, limit, pos):
    a = []
    for item in x:
        sig = round(5 + (limit/(1+math.exp(pos-item))), 2)
        a.append(sig)
    return a


#Calculate the Growth Degree days
def CalGDD(high, low):
    base = 7
    if (low < 7):
        if (high > 30):
            return (30 + 7) / 2 - base
        else:
            return (high + 7) / 2 - base
    elif (low > 30):
        return (30 + low) / 2 - base
    else:
        return (high + low) / 2 - base


#Get Last roll and add new roll in
def Spiral():
    global spiral
    spiral = spiral + rd.randint(50, 70)
    if spiral > 360:
        spiral = spiral - 360
    return spiral


#Global variable for plant location	print(Lfstore)
def PlantLoc(x, y):
    global Px
    global Py
    Px = x
    Py = y


def EucDist(x, y, z):
    A = ny.array((x, y, z))
    B = ny.array((Light_location_X, Light_location_Y, Light_location_Z))
    return ny.linalg.norm(A-B)


#Compare plant location with the point light location
def LightLoc(plant, light):
    if (Phototropism == True):
        diff = plant - light
        if (plant > light):
            return -1
        elif (diff <= 5 and diff >= -5):
            return 0
        else:
            return 1
    else:
        return 0

points  = ny.arange(0., 8., 0.15)
if (SDLD == True): 
    log = Sigmoid(points, 10, 4)
else:	
    log = Sigmoid(points, 20, 3)

for n in range(months):
    for y in range(MnthsDays[n][1]):
        #print(days[n][1])
        tempLow.append(RanTemp(n, mean, min))
        tempHigh.append(RanTemp(n, max, mean))

GDD = 0

Days = len(tempHigh)
for n in range(len(tempHigh)):
    GDD = GDD + CalGDD(tempHigh[n], tempLow[n])

total = GDD

"""
leafs = round(total / rd.randint(60, 66))
if (leafs > 30):
    leafs = 30
"""
leafs = LEAFS


def check_distance(point1, radius1, point2, radius2):
  x1, y1, z1 = point1
  x2, y2, z2 = point2
  distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2)
  if distance <= (radius1 + radius2):
    return True
  else:
    return False

def cube_distance(cube1_center, cube1_size, cube2_center, cube2_size):
  A = ny.array((cube2_center[0], cube2_center[1], cube2_center[2]))
  B = ny.array((cube1_center[0], cube1_center[1], cube1_center[2]))
  distance = ny.linalg.norm(B - A)
  if distance <= (cube1_size + cube2_size) / 2:
    return True
  else:
    return False

Axiom: Plight()  Farm(1, 1, 150/3)

derivation length: 7
production:

Plight():	
    if (Phototropism == True):
        nproduce [SetColor(4)@M(Light_location_X, Light_location_Y, Light_location_Z)@O(3)]

Farm(rows, columns, dist):
    st = time.time()
    x = 0
    y = 0
    for a in range(rows):
        
        for b in range(columns):
            PlantLoc(x, y)
            if specify_params:
              nproduce @M(x, y, 0) [SetColor(2)PC(leafs)]
            else:
              nproduce @M(x, y, 0) [SetColor(2)PC(leafs + rd.randint(-5, 5))]
            y = y + dist
        y = 0
        x = x + dist
    et = time.time()
    res = et - st
    print('CPU Execution time:', res, 'seconds')


#Primary Crown
PC(x):
    #If more than 10 leaves are generated generate fruit
    if specify_params:
        for a in range(0,N_TRUSSES):
          nproduce [Rol()INF(0)]
    elif (x >= 10):	
        for a in range(rd.randint(1, 3)):
            #component to generate the fruit
            nproduce [Rol()INF(0)]
    for leaf in range(x):
        #generate each leaf
        nproduce [Rol()L(leaf)]


#Branching Crown
BC(x):
    y = rd.randint(1, 2)
    if y == 2:
        for a in range(x):
            nproduce SetColor(5)+(10)F(0.1)[Rol()L()]
    else:
        for a in range(x):
            nproduce SetColor(5)-(10)F(0.1)[Rol()L()


#Calculate leaf weight (Unused)
LWeight(x):
    DryWeight = round(100 / x)
    nproduce @Tp(0,0,-1) Elasticity(abs(tropism)/DryWeight)


#Generate stem hairs
Hr(x):
    for a in range(x):
        len = float(decimal.Decimal(rd.randrange(0, 10))/10)
        nproduce: [SetColor(7)/(rd.randint(0, 360))nf(len, len)+(rd.randint(45, 120))_(0.001)@B(0.25)]


#Fruit
INF(x):
 #Create number of infloresence based on the mode of Riseholme data using Rayleigh
    if specify_params:          
        FruitWeight = round(2000 / (1 + float(decimal.Decimal(N_BERRIES*BERRY_SIZE)/5))) 
        #nproduce SetColor(0,0,255)/(5)+(15)@Tp(0,0,-1) Elasticity(abs(tropism)/(FruitWeight/3))nF(1.5, 0.1)[nF(N_STEPS_PED, PEDUNCLE_LEN, PEDUNCLE_RADIUS)Berries(int(N_BERRIES))]
        nproduce SetColor(0,0,255)+(75)@Tp(0,0,-1) Elasticity(abs(tropism)/FruitWeight) nF(N_STEPS_PED, PEDUNCLE_LEN, PEDUNCLE_RADIUS) [Berries(int(N_BERRIES))]

    else:
        s = rng.rayleigh(5, 1)
        truss_length = rd.randint(Truss_split_length[0], Truss_split_length[1])
        
        nproduce SetColor(2)+(75)@Tp(0,0,-1) Elasticity(abs(tropism)/1000.) nF(truss_length, 0.1) [Berries(int(s))]


#Berry generation
Berries(x):
  unique_rotation = rd.sample(range(0, 360 + 1), x)
  unique_angle = rd.sample(range(0, 50 + 1), x)
  for a in range(x):
    if specify_params:     
        nproduce [/(unique_rotation[a])+(unique_angle[a]) BWeight(BERRY_SIZE) nF(N_STEPS_CEL, PEDICEL_LEN, PEDICEL_RADIUS) ?P BerryRadius(BERRY_SIZE)]
    else:
        size = float(decimal.Decimal(rd.randrange(2, 5))/10)
        #nproduce /(rd.randint(0, 360))[BWeight(size)+(rotation)nF(3, 0.1) BerryLeaf() f(size) SetColor(10)TextureScale(1) ?P BerryRadius(size)]
        #BerryLeaf() SetColor(10)TextureScale(1)?P BerryRadius(size)
        nproduce [/(unique_rotation[a])+(unique_angle[a]) BWeight(size) TrussLength(size) ?P BerryRadius(size)]


TrussLength(r):
  Length = rd.randint(Truss_split_length[0], Truss_split_length[1])
  nproduce nF(Length, 0.2)

BerryLeaf():
    nproduce [+(90)/(90)~l(0.5)] [-(90)/(90)~l(0.5)] [/(90)+(90) /(90)~l(0.5)] [/(90)-(90) /(90)~l(0.5)]


BWeight(x):
    Size = round(50 / x)  
    nproduce @Tp(0,0,-1) Elasticity(abs(tropism)/Size)


?P(p) BerryRadius(r):
  fruit = [p, r]
  fruit_pos.append(fruit)
  for point in fruit_pos:
    if point[0] != p and cube_distance([p[0], p[1], p[2]], r, point[0], point[1]):
      nproduce nF(1, 0.1)
  nproduce BerryLeaf() SetColor(10)TextureScale(1)f(r)SetColor(255,0,0)@O(r)


#Stolon/Runner generation
ST(x):
    for a in range(x):
        nproduce +(5)@Tp(0,0,-1) Elasticity(abs(tropism)/1000.)nF(1, 0.1)


#Leaf polygon generation
L(x):
    if specify_params:
        eps = rng.rayleigh(10, 1)
        while eps < 0 or eps > 10:
            eps = rng.rayleigh(10, 1)
        eps = eps[0]  
        nproduce SetColor(0,255,0) TextureScale(1) LF((PETIOLE_LEN*N_STEPS_PETIOLE)+eps, x)
    else:
        #generate petiole length
        petiole = rng.uniform(ny.min(Petiole), ny.max(Petiole), 1)
        
        #set the colour and scale the texture
        nproduce SetColor(2) TextureScale(1)LF(round(petiole[0] / 2), x)


#Leaf generation
LF(x, leaf):
    #The current leaf 
    T = leafs - leaf

    if specify_params:
        
        eps = rng.rayleigh(1, 1)
        while eps < 0 or eps > 1:
            eps = rng.rayleigh(1, 1)
        eps = eps[0]        
        LeafArea = LEAF_AREA + eps
        #LeafArea = rng.rayleigh(4, 1)
        #loop to create new values in case the value generated was above the min or max of the original data	
        #while LeafArea < 1 or LeafArea > 5:
        #    LeafArea = rng.rayleigh(4, 1)
    
        #LeafArea = LeafArea[0]
    else:		
        #Generates leaves with rayleigh distribution based on the mode of the real data.
        LeafArea = rng.rayleigh(137, 1)
        #loop to create new values in case the value generated was above the min or max of the original data	
        while LeafArea < 30.41 or LeafArea > 323.64:
            LeafArea = rng.rayleigh(137, 1)
        
        LeafArea = ((LeafArea[0] / 3) / 3) / 3 
    
    #Get weight based on the leaf area
    DryWeight = round(5000 / 1 + float(decimal.Decimal(LeafArea)/5)) 
    
    #the older the leaf the bigger the angle
    angle = T * rd.randint(1, 10)
    #Cannot exceed 70 degrees
    
    if len(spiral_angle) > 0:
        for leaf_angle in spiral_angle:
            while angle > leaf_angle[0]-5 and angle < leaf_angle[0]+5 and spiral > leaf_angle[1]+10 and spiral < leaf_angle[1]-10:
                angle = angle + 5
                
                
    if (angle >  70):
        nproduce +(70)
    else:
        nproduce +(angle)
        
    if specify_params:
        eps = rng.rayleigh(1, 1)
        while eps < 0 or eps > 1:
            eps = rng.rayleigh(1, 1)
        eps = eps[0]*5
        print(eps)
        nproduce @Tp(LightLoc(Px, Light_location_X), LightLoc(Py, Light_location_Y),-1) Elasticity(abs(tropism)/DryWeight*10) nF(N_STEPS_PETIOLE+eps, PETIOLE_LEN, PETIOLE_RADIUS)
    else:
        nproduce @Tp(LightLoc(Px, Light_location_X), LightLoc(Py, Light_location_Y),-1) Elasticity(abs(tropism)/DryWeight) nF(x, 0.1)
    nproduce ?P LeafRadius(LeafArea/2)
    
    spiral_angle.append([angle, spiral])


og(x):
    nproduce ~l(x/2+0.5)+(90)~l(x/2+0.5)-(180)~l(x/2+0.5)


#Component to generate the trifolate
P(x):
  #nproduce TextureRotation(-90) ?P LeafRadius(x/2)
  if specify_params:
    nproduce SetColor(13,54,13) TextureRotation(-90) [/(90)+(5)f(x)/(-90)@o(x)] TextureRotation(-90) +(90) [/(90)+(15)f(x)/(-90)@o(x)] -(180)/(90)+(15)f(x)/(-90)@o(x)
  else:
    nproduce SetColor(9) TextureRotation(-90) [/(90)+(5)f(x)/(-90)@o(x)] TextureRotation(-90) +(90) [/(90)+(15)f(x)/(-90)@o(x)] -(180)/(90)+(15)f(x)/(-90)@o(x)
  #nproduce SetColor(9) TextureRotation(-90) [/(90)+(5)/(-90)f(x/2)?P LeafRadius(x/2)] TextureRotation(-90) +(90) [/(90)+(15)/(-90)f(x/2)?P LeafRadius(x/2)] -(180)/(90)+(15)/(-90)f(x/2)?P LeafRadius(x/2)


?P(p) LeafRadius(r):
    point_radius = [p, r]
    leaves_circle_pos.append(point_radius)
    for point in leaves_circle_pos:
        if point[0] != p and cube_distance([p[0], p[1], p[2]], r, point[0], point[1]):
            r = r / 2
    nproduce /(90)P(r)

Spr():
    nproduce /(rd.randint(-360, 360))


#Spiral generation
Rol():
    nproduce F(0.05)/(Spiral())


#Unused Polygon generation of leaf
Rf --> -(10)F(0.3)-(10)F(0.2)-(40)F+(10)F+(120)F(0.3)-(120)F(0.5)+(10)F(0.5)+(130)F(0.3)-(120)F(0.5)+(10)F(0.5)+(130)F(0.3)-(120)F(0.5)+(5)F(0.5)+(120)F(0.3)-(120)F(0.5)+(10)F(0.5)+(130)F(0.3)-(120)F(0.5)+(10)F(0.5)+(120)F(0.3)-(120)F(0.5)+(10)F(0.5)+(120)F(0.3)-(130)F(0.5)+(10)F(0.5)
Lf --> +(110)F(0.5)+(10)F(0.5)-(120)F(0.3)+(110)F(0.5)+(10)F(0.5)-(120)F(0.3)+(120)F(0.5)+(10)F(0.5)-(120)F(0.3)+(120)F(0.5)+(10)F(0.5)-(120)F(0.3)+(120)F(0.5)+(10)F(0.5)-(120)F(0.3)+(130)F(0.5)+(10)F(0.5)-(120)F(0.3)+(130)F(0.5)+(10)F(0.5)-(120)F(0.3)+(130)F+(10)F-(10)F(0.1)-(20)F(0.3)-(20)F(0.3)

endlsystem
###### INITIALISATION ######

__lpy_code_version__ = 1.1

def __initialiseContext__(context):
	import openalea.plantgl.all as pgl
	PGL_94035737448096 = pgl.ImageTexture("PGL_94035737448096" , "textures/leaf.png" , )
	PGL_94035737448096.name = "PGL_94035737448096"
	Color_0 = pgl.Texture2D(image = PGL_94035737448096 , )
	Color_0.name = "Color_0"
	context.turtle.setMaterial(0,Color_0)
	Color_2 = pgl.Material("Color_2" , ambient = (56,96,20) , diffuse = 1.125 , shininess = 1 , )
	Color_2.name = "Color_2"
	context.turtle.setMaterial(2,Color_2)
	Color_3 = pgl.Material("Color_3" , ambient = (0,0,0) , diffuse = 4.18605 , shininess = 0 , )
	Color_3.name = "Color_3"
	context.turtle.setMaterial(3,Color_3)
	Color_4 = pgl.Material("Color_4" , ambient = (60,60,15) , diffuse = 3 , emission = (234,255,0) , )
	Color_4.name = "Color_4"
	context.turtle.setMaterial(4,Color_4)
	Color_7 = pgl.Material("Color_7" , ambient = (178,206,171) , diffuse = 0.68932 , )
	Color_7.name = "Color_7"
	context.turtle.setMaterial(7,Color_7)
	PGL_94168359224304 = pgl.ImageTexture("PGL_94168359224304" , "textures/stem_drk.png" , )
	PGL_94168359224304.name = "PGL_94168359224304"
	Color_8 = pgl.Texture2D(image = PGL_94168359224304 , )
	Color_8.name = "Color_8"
	context.turtle.setMaterial(8,Color_8)
	PGL_94168373592928 = pgl.ImageTexture("PGL_94168373592928" , "textures/leaf.png" , )
	PGL_94168373592928.name = "PGL_94168373592928"
	Color_9 = pgl.Texture2D(image = PGL_94168373592928 , )
	Color_9.name = "Color_9"
	context.turtle.setMaterial(9,Color_9)
	PGL_94168345223024 = pgl.ImageTexture("PGL_94168345223024" , "textures/strawb.jpeg" , )
	PGL_94168345223024.name = "PGL_94168345223024"
	Color_10 = pgl.Texture2D(image = PGL_94168345223024 , )
	Color_10.name = "Color_10"
	context.turtle.setMaterial(10,Color_10)
	scalars = [('tropism', 'Float', 9.81, 0.0, 99.99, 2), ('Hair', 'Bool', False), ('Point Light', 'Category'), ('Light_location_Z', 'Integer', 20, 0, 100), ('Light_location_Y', 'Integer', 25, 0, 100), ('Light_location_X', 'Integer', 0, 0, 100), ('Phototropism', 'Bool', False), ('Days', 'Category'), ('Days', 'Integer', 140, 0, 1000), ('SDLD', 'Bool', False), ('months', 'Integer', 7, 1, 12), ('start', 'Integer', 2, 1, 12)]
	context["__scalars__"] = scalars
	for s in scalars:
		if not s[1] == "Category" : context[s[0]] = s[2]
